<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Propriétés des pièces</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the different room properties" />
  <meta name="rh-index-keywords" content="Rooms - Room Settings" />
  <meta name="search-keywords" content="room settings,cameras,viewports,room size,room properties,view cameras" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Propriétés des pièces</h1>
  <p><img>La section Propriétés de la pièce vous permet de définir l'héritage des paramètres, de modifier des options telles que la persistance, la taille de la pièce et de gérer les fenêtres d'affichage.</p>
  <h2>Persistant</h2>
  <p>Normalement, lorsque vous quittez une pièce et que vous y retournez plus tard, cette pièce est réinitialisée à ses paramètres initiaux. Cela convient généralement à la plupart des jeux, mais ce n'est peut-être pas ce que vous voulez, par exemple, dans un RPG ou un jeu non linéaire, où vous voulez aller et venir entre les pièces et faire en sorte qu'elles soient dans l'état où vous les avez laissées la dernière fois. En cochant la case " <strong>Persistant" </strong>, vous obtiendrez exactement cela. L'état de la pièce sera mémorisé et lorsque vous y retournerez plus tard, elle sera exactement comme vous l'avez laissée, et ne sera remise à l'état initial que lorsque vous redémarrerez le jeu. Notez qu'il y a <em>une </em>exception à cette règle : si vous avez marqué certains objets comme étant persistants, les instances de ces objets <em>ne </em>resteront <em>pas </em>dans la pièce mais se déplaceront dans la pièce suivante.</p>
  <h2 id="clear_display_buffer">Effacer le tampon d'affichage</h2>
  <p>Ensuite, vous avez la possibilité d'<strong>effacer le tampon d'affichage</strong>. Cette option, lorsqu'elle est cochée, pré-remplit le <a class="glossterm" data-glossterm="tampon d'affichage" href="#">tampon d'affichage</a> avec une couleur avant de dessiner quoi que ce soit d'autre pour une image particulière. Si vous savez que vos vues vont couvrir tout l'écran à tout moment ou que vous avez un arrière-plan opaque en plein écran, vous pouvez décocher cette option, ce qui évite de redessiner l'écran et permet d'optimiser votre jeu.</p>
  <p>Toutefois, si vous avez plusieurs vues qui, lorsqu'elles sont affichées à l'écran, laissent des espaces ouverts, ou si votre arrière-plan comporte des parties transparentes, vous pouvez cocher cette case pour que toutes les zones vides soient remplies avec la couleur de dessin de votre choix. Actuellement, cette couleur ne peut être définie que par le code en utilisant <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/The_Game_Window/window_set_colour.htm"><span class="inline">window_set_colour()</span></a>.</p>
  <p class="note"><span class="note">REMARQUE</span>: si vous utilisez la correction automatique du rapport hauteur/largeur (définie dans les <a href="../../Settings/Game_Options.htm">options du jeu</a>), vous devez <strong>toujours </strong>cocher cette option, sinon vous risquez d'obtenir des effets bizarres sur la &quot;boîte aux lettres&quot; dans laquelle votre jeu est dessiné. Si vous n'utilisez pas cette option, vous pouvez la décocher et obtenir une petite amélioration des performances de vos jeux (particulièrement visible sur <span class="notranslate">Android</span> et d'autres plateformes mobiles).</p>
  <h2>Largeur, hauteur et autres options</h2>
  <p>Une pièce doit avoir une taille et celle-ci est définie par les valeurs que vous saisissez pour sa largeur et sa hauteur en pixels.</p>
  <p>Vous pouvez ensuite ajouter le <strong>code de création</strong>, si vous en avez besoin. Le code de création est ajouté à l'aide du bouton situé en bas de l'écran (ainsi que la case à cocher "hériter" qui permet de déterminer si la room doit hériter de son code de création ou non), et si vous cliquez dessus, vous ouvrirez un éditeur de code ou visuel. Cet éditeur vous permet d'entrer des fonctions/actions et du code qui seront exécutés au <em>début </em>de la room, après l'événement de création de toutes les instances mais avant leur événement de début de room (pour plus d'informations sur l'ordre des événements, veuillez voir <a href="../Object_Properties/Event_Order.htm">ici</a>). Ce code sera exécuté chaque fois que vous entrerez dans la room, à moins que la room ne soit marquée comme persistante, auquel cas il ne sera exécuté qu'une seule fois lors de la première entrée dans la room, mais pas lors des visites ultérieures de la room.</p>
  <h2 id="creation_order">Ordre de création de l'instance</h2>
  <p>Le dernier bouton des propriétés de la pièce vous permet d'ouvrir la fenêtre <strong>Ordre de création de l'instance</strong>:</p>
  <p><img>Cette fenêtre liste toutes les instances de la salle dans l'ordre où elles seront créées (de haut en bas). Si vous souhaitez qu'une instance spécifique soit créée avant une autre, vous pouvez simplement cliquer sur <img> et la faire glisser vers la position souhaitée. Notez que les instances seront créées dans l'ordre donné de haut en bas de la liste.</p>
  <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
  <p> </p>
  <p> </p>
  <h1>Caméras et miradors</h1>
  <p>Le prochain ensemble de propriétés que vous pouvez définir pour la pièce est celui qui concerne la <strong>caméra</strong> et les <strong>fenêtres de</strong> la pièce. Les vues caméra offrent un mécanisme permettant de dessiner différentes parties de votre pièce à différents endroits de l'écran, ou de dessiner une partie seulement de votre pièce pour couvrir tout l'écran. Par exemple, dans la plupart des jeux de plates-formes, la vue de la caméra suit le personnage principal, car si vous pouviez voir tout le niveau à l'écran, votre personnage serait trop petit pour être vu et il n'y aurait pas de surprises pour le joueur. Les vues de caméra peuvent également être utilisées dans les jeux multi-joueurs ou les jeux de coopération, car elles permettent de créer une configuration d'écran partagé dans laquelle une partie de l'écran est occupée par un joueur et une autre partie par l'autre joueur. Tout cela peut être facilement réalisé dans <span data-keyref="GameMaker Name">GameMaker</span> grâce aux vues de caméra.</p>
  <p><img>En haut des propriétés de la vue, vous pouvez activer ou désactiver l'héritage de la vue, puis il y a une case intitulée <strong>Enable Viewports</strong>. Cette <em>case doit être cochée</em> avant qu'une des vues de la caméra puisse être utilisée dans votre jeu.</p>
  <p class="note"><span class="note">REMARQUE</span> Vous pouvez activer ou désactiver l'héritage pour les trois paramètres principaux de la fenêtre d'affichage, puis activer ou désactiver l'héritage pour chaque vue de caméra individuelle.</p>
  <p>La case à cocher suivante est celle qui indique <strong>Clear Viewport Background</strong>, qui est similaire à l'option <a href="#clear_display_buffer">Clear Display Buffer</a> donnée ci-dessus, mais pour les fenêtres d'affichage spécifiquement. Lorsqu'elle est activée, elle efface la <a class="glossterm" data-glossterm="surface de pose" href="#">surface de l'application</a> avec la couleur de la fenêtre avant de dessiner chaque image. Cela permet de s'assurer que vous ne voyez pas de graphiques involontaires à travers les zones transparentes de votre arrière-plan, comme le contenu de toutes les images précédentes ; il est donc important d'activer cette option (avec &quot;<strong>Activer les fenêtres</strong>&quot;) si votre arrière-plan contient de la transparence.</p>
  <p>Une vue de caméra est définie par deux ensembles de valeurs différents, la vue de caméra elle-même et le port de l'écran où cette vue doit être dessinée. Cela peut parfois prêter à confusion, alors expliquons un peu cela avant d'expliquer comment nous définissons chacun d'eux :</p>
  <ul class="colour">
    <li><strong>La caméra</strong>: Un point dans la pièce qui sera utilisé pour définir la façon dont la pièce est affichée à l'écran (il s'agit d'un point abstrait dans l'éditeur de pièce et sa position est définie automatiquement en fonction des paramètres de vue et de port de vue).</li>
    <li><strong>La vue</strong>: Ce que la caméra voit, en fonction de la position, de la projection et de la rotation de la caméra.</li>
    <li><strong>Le port de vue</strong>: la zone de l'écran physique où la vue de la caméra sera affichée.</li>
  </ul>
  <p><img>Ainsi, par exemple, cela signifie que vous pouvez avoir une vue de caméra de 640x480 dans votre pièce, puis régler le port sur 320x240, ce qui affichera la vue à l'écran à l'échelle du port de cette taille, et vous pouvez également faire la même chose et régler la vue sur une valeur plus petite et le port sur une valeur plus grande, ce qui fait que l'image s'adapte à la taille du port et est affichée à l'écran plus grande qu'elle ne l'est. De cette façon, vous pouvez maintenir une taille d'écran (port) tout en changeant la vue de la caméra pour afficher plus ou moins de la pièce dans la même zone de l'écran.</p>
  <p>La vue de la caméra est toujours définie comme une zone rectangulaire dans la pièce, où vous spécifiez la position du coin supérieur gauche, la largeur et la hauteur de cette zone. Vous devez ensuite spécifier l'endroit où cette zone est affichée dans la fenêtre de l'écran en définissant le port de vue, où vous spécifiez à nouveau la position du coin supérieur gauche et la taille (notez que tout ce qui est différent de 0,0 pour le coin supérieur gauche peut donner des résultats étranges). Vous pouvez avoir plus d'un port et ils peuvent se chevaucher, auquel cas ils sont dessinés dans l'ordre indiqué, l'un au-dessus de l'autre.</p>
  <p>Veuillez noter que la zone globale de l'écran est <em>toujours définie comme une zone rectangulaire</em>, donc vos ports, même lorsqu'ils sont décalés, formeront un rectangle, avec tous les espaces vides étant remplis par la couleur de la fenêtre du <a class="glossterm" data-glossterm="tampon d'affichage" href="#">tampon d'affichage</a>, ce qui signifie que dans ces circonstances, vous devriez toujours avoir la case <strong>"Clear Display Buffer"</strong> cochée, sinon vous obtiendrez des artefacts bizarres dessinés dans les espaces entre les ports. L'image ci-dessous illustre cela, où il y a deux ports de vue décalés visibles, mais ils forment une fenêtre carrée, et &quot;en dessous&quot; il y a des lignes dessinées dans le tampon d'affichage :</p>
  <p><img>Les caméras disposent également d'une option de <strong>suivi d'objet </strong>. Cette option est utilisée lorsque vous souhaitez que la caméra &quot;suive&quot; (c'est-à-dire que la vue reste centrée sur) un objet donné. Pour ce faire, vous devez cliquer sur <img> sur l'icône du menu et sélectionner un objet dans la liste qui s'affiche (s'il y a plusieurs instances de cet objet dans la pièce, seul l'un d'entre eux est suivi par la caméra).</p>
  <p>Le comportement normal d'une caméra est de ne bouger que lorsque l'instance suivie s'approche trop près d'une zone &quot;tampon&quot; qui constitue une frontière invisible autour du bord de la vue. Vous pouvez définir cette zone à l'aide des valeurs <strong>Horizontal Border </strong>et <strong>Vertical Border </strong>. Par exemple, si vous fixez ces valeurs à 64, la vue ne commencera à se déplacer et à suivre le personnage que lorsqu'il sera à 64 pixels du bord de la vue.</p>
  <p>Enfin, vous pouvez indiquer la <strong>vitesse </strong> <strong>horizontale</strong> et <strong>verticale </strong>à laquelle la caméra se déplace lorsque le personnage a atteint la zone <span class="notranslate">buffer</span>. La valeur par défaut est -1. Cette valeur par défaut est fondamentalement &quot;instantanée&quot; et signifie que dès que l'instance de suivi se trouve en dehors de la zone de la bordure horizontale ou de la bordure verticale <span class="notranslate">buffer</span>, la vue passe à sa position actuelle. Ce n'est pas toujours ce que vous souhaitez et vous pouvez donc définir la vitesse de défilement vertical et horizontal de la caméra en donnant à ces valeurs une valeur différente de -1. Notez qu'avec une valeur de 0, la vue ne bougera pas du tout, et que toute autre valeur positive représente le nombre de pixels qu'elle déplacera dans une image. Ainsi, en définissant la vitesse horizontale sur 5, la vue suivra l'objet horizontalement à raison de 5 pixels par image.</p>
  <p> </p>
  <p> </p>
  <h1>Physique des salles</h1>
  <p>Avant de pouvoir utiliser les fonctions physiques intégrées dans vos jeux, vous devez indiquer à <span data-keyref="GameMaker Name">GameMaker</span> que la pièce est une pièce physique. Pour ce faire, vous devez cocher l'option <strong>Enable Physics </strong>en haut de la section <em>Room Physics (</em> vous pouvez également basculer l'héritage de cette section indépendamment du reste des paramètres de la pièce). Une fois que vous avez fait cela, vous pouvez continuer à configurer les propriétés du monde physique, qui sont quelques propriétés de base que vous devez avoir prédéfinies avant que votre pièce permette aux instances physiques de fonctionner en tant que telles. Pour un contrôle plus précis du monde, vous pouvez utiliser du code (voir les <a href="../../GameMaker_Language/GML_Reference/Physics/Physics.htm">fonctions physiques</a> pour plus d'informations).</p>
  <p><img>La prochaine chose à faire est de configurer la <strong>gravité </strong>du monde. La force et la direction de celle-ci sont calculées comme un <a class="glossterm" data-glossterm="vecteur" href="#">vecteur</a> de la position x/y que vous définissez autour d'un point (0, 0). Ainsi, avec un x de 0 et un y de 1, la direction de la gravité sera <em>vers le bas </em>avec une force de 1 mètre par seconde (pour une explication plus détaillée, voir - <a href="../../GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm">Le monde de la physique</a>).</p>
  <p>Enfin, vous devez définir le ratio<strong> Pixels/Mètres</strong> que <span data-keyref="GameMaker Name">GameMaker</span> utilisera comme base pour tous ses calculs de physique. Les fonctions physiques fonctionnent sur des mesures du monde réel, c'est pourquoi nous devons définir cette valeur. Vous voudrez ajuster ce paramètre jusqu'à ce que la taille moyenne des pixels des objets que vous utilisez se traduise approximativement en objets physiques simulés de taille appropriée.</p>
  <p>Il faut noter que l'activation de la physique dans une room signifie que toutes les instances de la room <em>doivent utiliser les fonctions et variables de la physique pour se déplacer</em>. Fondamentalement, vous avez le mouvement &quot;traditionnel&quot;, où vous pouvez définir la position X/Y d'une instance ou définir sa vitesse et sa direction, et ensuite vous avez le mouvement &quot;physique&quot;, qui nécessite des forces et des impulsions physiques pour se déplacer. Ces systèmes sont <strong>mutuellement exclusifs</strong>, et vous ne pouvez pas déplacer une instance physique en utilisant des fonctions non-physiques et vous ne pouvez pas déplacer une instance non-physique en utilisant les fonctions physiques.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="../Rooms.htm">L'éditeur de pièces</a></div>
        <div style="float:right">Suivant : <a href="Room_Inheritance.htm">Héritage des pièces</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Room Properties
View Ports
View Cameras
-->
  <!-- TAGS
rooms_properties
-->
</body>
</html>