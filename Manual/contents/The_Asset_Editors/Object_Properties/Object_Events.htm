<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Événements relatifs aux objets</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page detailing the events system and the different events in an object" />
    <meta name="rh-index-keywords" content="Objects - Events" />
    <meta name="search-keywords" content="events,object events,events list" />
    <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
    <script src="../../assets/scripts/main_script.js"></script>
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Événements relatifs aux objets</h1>
    <p>Alors, que sont les <strong>événements d'</strong>objets ? En gros, ce sont des moments discrets dans la boucle du jeu où les choses se produisent en fonction de ce que vous avez programmé pour elles. <span data-keyref="GameMaker Name">GameMaker</span> fonctionne avec des cycles de ces événements - à partir du moment où une pièce est commencée jusqu'au moment où elle est terminée, il y a une boucle de jeu en cours d'exécution où, à chaque <strong>étape, une </strong>série d'événements sont exécutés ou vérifiés, et vous pouvez choisir de placer du code ou des actions visuelles <span class="notranslate">GML</span> dans vos objets qui répondent à ces événements (une étape est un moment dans le temps de jeu, régi par le paramètre de vitesse de la pièce, et peut également être appelé une <strong>image</strong>).</p>
    <p>Examinons la configuration typique d'un objet avec des événements et du code :</p>
    <p><img>Comme vous pouvez le voir dans notre exemple d'objet, il y a un certain nombre d'événements listés auxquels il doit répondre, mais initialement, lorsque vous créez un objet, cette liste est vide et vous devez décider des événements dont vous avez besoin et de ce que les instances de cet objet doivent faire lorsque ces événements sont déclenchés. Pour ajouter des événements à l'objet, vous devez appuyer sur le bouton <em>Add Event (Ajouter un événement)</em> situé en bas de la liste des événements, ce qui fait apparaître la fenêtre suivante :</p>
    <p><img>Il s'agit de la liste de tous les événements de base et de toutes les catégories d'événements auxquels un objet peut répondre. Dans chaque catégorie, des sous-événements permettent d'affiner les comportements. Par exemple, si vous cliquez sur la catégorie d'événement<strong>Key Press</strong> <img>, une autre fenêtre s'ouvre avec les événements qui vous permettent de sélectionner <em>la </em>touche à laquelle l'objet doit répondre.</p>
    <p>Une fois que vous avez sélectionné votre événement, la fenêtre de l'éditeur de l'événement sera enchaînée à celui-ci et s'ouvrira à droite.</p>
    <div data-conref="../../assets/snippets/Visual_Code_Choice.hts"> </div>
    <p>Vous pouvez maintenant modifier le code (ou les blocs) de <span class="notranslate">GML</span> pour donner à votre objet un comportement ou une réaction spécifique à cet événement.</p>
    <p>Vous pouvez cliquer avec le bouton droit de la souris <img> sur n'importe quel événement qui a été ajouté à un objet pour obtenir les options de menu suivantes :</p>
    <p><img>Ces options sont :</p>
    <ul class="colour">
      <li><strong>Ajouter un événement</strong> - Ajouter un nouvel événement à partir de la liste des événements.</li>
      <li><strong>Couper / </strong> <strong>Copier / </strong> <strong>Coller des événements</strong> - Couper, copier ou coller l'événement sélectionné. Vous pouvez également utiliser les raccourcis clavier standard : <img> / <img> + <span class="inline">X</span>, <img> / <img> + <span class="inline">C</span>, et <img> / <img> + <span class="inline">V</span>.</li>
      <li><strong>Dupliquer l'événement</strong> - Dupliquer l'événement choisi. Cette opération prend le contenu de l'événement choisi et le duplique dans un autre événement que vous spécifiez.</li>
      <li><strong>Modifier l'événement</strong> - Pour modifier l'événement. Vous serez invité à choisir une autre catégorie d'événement et, une fois sélectionné, le contenu de l'événement actuel sera modifié en fonction du nouvel événement (en supprimant l'événement original).</li>
      <li><strong>Convertir en <span class="notranslate">GML</span> Visual / Code</strong> - Les événements d'objets seront créés en utilisant la méthode choisie lors de la création du projet, soit en utilisant le code, soit en utilisant les actions de <span class="notranslate">GML</span> Visual. Cette option vous permet de convertir de l'une à l'autre, quel que soit le type de projet.</li>
      <li><strong>Supprimer l'événement</strong> - Supprime l'événement (ou les événements).</li>
    </ul>
    <p>Lorsque vous supprimez des événements, vous pouvez utiliser <img> + <img> pour sélectionner plusieurs événements et les supprimer tous ensemble.Chaque objet que vous créez possède sa propre liste discrète d'événements qui lui sont ajoutés à partir de l'<strong>éditeur d'objets</strong>. Ces événements se répartissent en deux catégories :</p>
    <ul class="colour">
      <li>ceux qui exécutent chaque étape du jeu</li>
      <li>celles qui sont &quot;déclenchées&quot; par un événement du jeu, comme le fait que l'instance atteigne le bord de la pièce ou une pression sur le clavier ou la souris.</li>
    </ul>
    <p>La liste complète des événements est donnée ci-dessous :</p>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down8" href="#">Créer</a></p>
    <div class="droptext" data-targetname="drop-down8">
      <p class="dropspot">Cet événement se produit lorsqu'une instance de l'objet est créée pour la première fois, et c'est la toute première chose qui se produit dans une instance placée dans la room via le Room Editor lorsqu'on y entre. Cela signifie que cet événement est l'endroit idéal pour initialiser des<span class="glossextra">variables</span>, démarrer des <a href="../Timelines.htm">lignes de temps</a>, définir des <a href="../Paths.htm">chemins</a>, etc... et faire tout ce qui ne doit généralement être fait qu'une seule fois ou seulement lorsqu'une instance est créée pour la première fois dans la room. Si votre objet a des <strong>variables d'objet</strong> ou des <strong>variables d'instance</strong> ajoutées dans l'éditeur d'objet ou l'éditeur de salle, ces variables seront d'abord initialisées, puis l'<strong>événement de création</strong> sera exécuté.</p>
      <p class="dropspot">Rappelez-vous que vous pouvez modifier tout ce que vous avez configuré dans l'événement de création à partir du <a href="../Room_Properties/Layer_Properties.htm">code de création d'instance</a> dans l'éditeur de salle, car il est exécuté directement après l'événement de création de l'instance et peut être utilisé pour créer des <strong>variables d'instance</strong> ou pour remplacer toute variable ajoutée en tant que variable d'objet ou dans l'événement de création actuel.</p>
      <div data-conref="../../assets/snippets/Instance_creation_order_warning.hts"> </div>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down9" href="#">Détruire</a></p>
    <div class="droptext" data-targetname="drop-down9">
      <p class="dropspot">Cet événement est l'événement à exécuter lorsqu'une instance est détruite. Il est souvent négligé lors de l'ajout de comportements aux objets, mais il peut être très utile, par exemple en créant des effets d'explosion ou de particules lorsqu'un ennemi est tué, ou pour faire réapparaître une nouvelle instance de l'objet dans une autre partie de la pièce, ou même pour ajouter des points à un score.</p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">Nettoyage</a></p>
    <div class="droptext" data-targetname="drop-down10">
      <p class="dropspot"><span>Cet événement sera appelé après tout événement qui supprime une instance de l'objet de la pièce. Ainsi, il sera déclenché si :</span></p>
      <ul class="dropspotlist">
        <li class="dropspot"><span>l'instance est détruite</span></li>
        <li class="dropspot"><span>la pièce se termine</span></li>
        <li class="dropspot"><span>le jeu se termine</span></li>
      </ul>
      <p class="dropspot"><span>Il est conçu pour que vous l'utilisiez pour &quot;nettoyer&quot; toutes les ressources dynamiques que vous pouvez avoir dans votre jeu (comme les surfaces, les structures de données, etc...) ou pour effectuer toute tâche dont vous avez besoin <em>une fois que </em>l'instance est retirée du jeu de quelque manière que ce soit.</span></p>
      <p class="dropspot"><span>Notez que cet événement sera appelé <em>immédiatement </em>après l'événement qui l'a déclenché, mais l'instance ne sera pas réellement retirée du jeu <strong>avant la fin de l'événement en cours</strong>. Par exemple, si vous appelez <span class="inline">instance_destroy()</span> dans l'événement Step, l'événement Destroy sera appelé, puis l'événement Clean Up, et enfin <em>le reste de l'événement Step se terminera</em>. Cela signifie que tout code que vous avez après l'appel à <span class="inline">instance_destroy()</span> sera toujours exécuté et sera une cause potentielle d'erreurs si vous avez nettoyé une structure de données ou toute autre ressource dont le code a besoin, il faut donc faire attention en utilisant cet événement.</span> </p>
      <p> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down11" href="#">Alarme</a></p>
    <div class="droptext" data-targetname="drop-down11">
      <p class="dropspot">La catégorie d'alarme est divisée en 12 événements, un pour chacune des alarmes possibles qui peuvent être définies dans une instance. Ainsi, lorsque vous cliquez sur la catégorie " <em>Ajouter une alarme </em>", vous obtenez cette fenêtre :</p>
      <p class="dropspot"><img>Ici, vous sélectionnez l'alarme que vous souhaitez créer et, une fois que c'est fait, vous verrez qu'elle a été ajoutée à la fenêtre d'événement, ce qui vous permet d'y ajouter du code comme d'habitude. Mais qu'est-ce qu'une alarme ? Il s'agit d'un événement spécial qui ne fait rien, à moins que l'alarme n'ait été réglée au préalable. Il attend alors que l'alarme ait décompté jusqu'à 0 avant d'exécuter les actions ou le code que vous lui avez ajoutés.</p>
      <p class="dropspot">Une fois que l'alarme a atteint 0 et que le code a été exécuté, elle décompte jusqu'à -1, où elle reste jusqu'à ce qu'elle soit à nouveau définie (vous pouvez donc vérifier la valeur d'une alarme pour voir si elle est supérieure à -1, ce qui vous indiquera si elle est en cours d'exécution ou non). Ainsi, si vous fixez la valeur de <span class="inline">alarm[0]</span> à 30 dans l'événement de création de l'objet, cela signifie que <span data-keyref="GameMaker Name">GameMaker</span> comptera 30 étapes de jeu avant d'exécuter les actions ou le code placés dans l'événement <span class="inline">alarm[0]</span>. Notez que si vous définissez une alarme à 0, le code d'alarme <em>ne sera pas </em>exécuté, car l'événement est déclenché, mais l'alarme est immédiatement définie à -1, et le code est donc ignoré. Si vous avez besoin d'une alarme pour exécuter l'étape suivante, vous devez la définir sur 1.</p>
      <p class="dropspot">Cela peut être très utile car cela vous permet de mettre des choses en mouvement à des moments précis, et vous pouvez même les faire répéter car rien ne vous empêche de définir une alarme dans son propre événement. Imaginez que vous ayez un monstre et que vous vouliez qu'il tourne à droite toutes les trois secondes... Eh bien, vous fixeriez une alarme dans son événement de création à la vitesse de la pièce * 3 (si la vitesse de la pièce est de 30, cela fait 30 pas par seconde, donc multipliez par 3 et vous obtenez 3 secondes !) et ensuite, dans l'événement d'alarme, vous auriez le code ou l'action pour définir sa direction, ainsi que l'action (ou le code) pour régler à nouveau son alarme à la vitesse de la pièce * 3. De cette façon, vous pouvez mettre en place des boucles de jeu simples où les choses ne se produisent qu'à des intervalles spécifiques.</p>
      <p class="dropspot">Il convient de noter qu'une alarme ne contenant aucune action ni aucun code n <em>'effectuera pas </em>de décompte. Cependant, même avec un simple commentaire et sans code ou action, l'alarme continuera à décompter et pourra être réglée et vérifiée comme vous le feriez normalement.</p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down12" href="#">Étape</a></p>
    <div class="droptext" data-targetname="drop-down12">
      <p class="dropspot"><span data-keyref="GameMaker Name">GameMaker</span> divise le temps en <strong>étapes </strong>, la vitesse de la pièce définissant le nombre de ces étapes par seconde (une étape peut également être appelée une <strong>image</strong>). Une étape est en fait la boucle qui tourne constamment avec tous les événements vérifiés et déclenchés si nécessaire pendant le déroulement du jeu. Comme vous pouvez l'imaginer, l'<strong>événement Step </strong>est un événement qui est vérifié à chaque étape du jeu pendant que l'instance existe.</p>
      <p class="dropspot">L'événement "step" est en fait composé de trois sous-événements qui sont décrits ci-dessous :</p>
      <p class="dropspot"><img>Pour la plupart des choses, l'événement step standard conviendra parfaitement, mais vous voudrez parfois avoir un peu plus de contrôle sur le code qui s'exécute et à quel moment, et pour cela vous disposez des événements step <strong>Begin </strong>et <strong>End </strong>. Ces trois événements sont vérifiés à chaque étape, mais leur ordre ne variera jamais, même si des mises à jour futures du moteur de <span data-keyref="GameMaker Name">GameMaker</span> modifient d'autres événements, ce qui signifie qu'il s'agit de la seule méthode fiable pour s'assurer que quelque chose se produit toujours avant quelque chose d'autre.</p>
      <p class="dropspot">A quoi peut servir l'événement step ? Eh bien, il peut être utilisé pour des actions ou du code qui doivent être exécutés en continu. Par exemple, si un objet doit en suivre un autre, vous pouvez ici adapter la direction du mouvement vers l'objet que nous suivons pour qu'il continue à se déplacer en douceur derrière. Faites cependant attention avec cet événement et ne mettez pas d'actions compliquées dans l'événement step des objets, surtout si vous prévoyez d'avoir beaucoup d'instances de l'objet dans votre salle de jeu, car cela pourrait ralentir le jeu. Beaucoup de choses peuvent être placées dans des alarmes, ou réglées pour se déclencher en utilisant certains des <strong>autres </strong>événements, plutôt que de se produire tout le temps.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">Collision</a></p>
    <div class="droptext" data-targetname="drop-down13">
      <p class="dropspot">Il est évident que lorsque vous créez un jeu, il est très important que vous sachiez quand deux instances (ou plus) d'un objet sont entrées en collision, et pour cela nous avons l'<strong>événement de collision</strong>. Il s'agit d'un événement que vous placez dans un objet et qui spécifie ensuite l'autre objet avec lequel vous devez vérifier les collisions.</p>
      <p class="dropspot">Si la physique n'est pas activée, ces collisions seront calculées en fonction du masque des deux objets (le masque est défini dans les propriétés de <span class="notranslate">sprite</span>, ou peut être attribué indépendamment dans les propriétés de l'objet) et du fait qu'ils se chevauchent ou non. Notez que si l'une ou l'autre des instances de la collision n'a pas de masque attribué (ou si le masque de <span class="notranslate">sprite</span> n'est pas défini), <em>même si elle dessine quelque chose</em>, aucune collision ne sera détectée.</p>
      <p class="dropspot">Si vous avez activé la <strong>physique </strong>, la collision sera basée sur le type de <strong>forme de collision</strong><em>(Fixture</em>) que vous avez défini pour l'objet dans ses propriétés physiques, tout comme sa réaction à la collision. Cela signifie que vous n'aurez peut-être pas besoin de code pour gérer la collision, mais cet événement <em>devra </em>tout de même <em>contenir au moins un commentaire </em>pour que les collisions soient détectées.</p>
      <p class="dropspot">Enfin, il convient de noter que toutes les collisions seront calculées une fois par étape de jeu avant le déclenchement de l'événement de collision, de sorte que lorsque l'événement de collision s'exécute, toutes les collisions auront déjà été calculées et préaffectées. Cela signifie que si vous créez une instance dans cet événement et que vous essayez ensuite de vérifier une collision avec elle, la collision ne sera pas détectée ou résolue avant l'<a class="glossterm" data-glossterm="itération" href="#">itération</a> suivante de la boucle de jeu.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Clavier,</a>  <img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Keyboard Press,</a>  <img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">Libération du clavier</a></p>
    <div class="droptext" data-targetname="drop-down14">
      <p class="dropspot">Il est très important de laisser le joueur contrôler les différents aspects de votre jeu, et à cette fin, <span data-keyref="GameMaker Name">GameMaker</span> vous fournit une liste très complète d'événements clavier qui peuvent être utilisés dans n'importe laquelle des trois catégories principales de clavier. Pour la catégorie Clavier général, les événements sont déclenchés en continu à chaque étape tant que la touche sélectionnée est enfoncée, tandis que les événements de la catégorie Enfoncer et relâcher ne sont déclenchés qu'une seule fois lorsque la touche est enfoncée ou relâchée initialement.</p>
      <p class="dropspot">Il convient de noter que les événements clavier sont en fait déclenchés dans toutes les instances actives d'une pièce chaque fois qu'une touche est utilisée, mais seules celles qui ont un événement défini pour cette touche particulière répondront et vous pouvez créer plusieurs événements clavier dans n'importe quel objet et les instances de cet objet répondront à tous les événements pendant le déroulement du jeu.</p>
      <p class="dropspot">Lorsque vous ajoutez un événement clavier à un objet, le menu des sous-événements clavier s'affiche et vous permet de spécifier la touche à vérifier :</p>
      <p class="dropspot"><img>La plupart d'entre eux sont assez évidents, mais passons en revue les sections brièvement : en haut, nous avons les touches fléchées, suivies des touches de modification les plus utilisées, puis le reste du clavier (divisé en sous-sections supplémentaires pour que vous puissiez obtenir la touche exacte requise comme <img> ou <img>) et enfin deux sous-événements très spéciaux, <strong>No Key</strong> et <strong>Any Key</strong>. Comme leur nom l'indique, ce sont des sous-événements qui vérifient si <em>aucune </em>touche <em>n'</em>est enfoncée ou si <em>une </em>touche est enfoncée. Veuillez noter que les touches du pavé numérique ne produisent les événements correspondants que lorsque le <strong>verrouillage numérique </strong>est activé.</p>
      <p class="dropspot">Les événements <strong>Press </strong>and <strong>Release </strong>pour le clavier sont presque exactement les mêmes que l'événement clavier normal, sauf qu'au lieu d'être déclenchés en continu, ils ne le sont qu'une fois. Lorsque le clavier enregistre pour la première fois qu'une touche a été enfoncée, il génère un événement <strong>Keyboard Pressed (</strong> ainsi qu'un événement Keyboard normal), et la première fois après cela où une touche n'est plus détectée comme enfoncée, il déclenche un seul événement <strong>Keyboard Release</strong>.</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Souris</a></p>
    <div class="droptext" data-targetname="drop-down16">
      <p class="dropspot">La catégorie Souris est séparée en une série d'événements qui peuvent être sélectionnés pour vous donner un contrôle plus précis sur ce qui se passe dans votre jeu. Vous pouvez voir ici ce que sont exactement ces événements :</p>
      <p class="dropspot"><img>Les événements des boutons gauche <img>, droit <img> et central <img> (qu'ils soient <strong>normaux</strong>, <strong>enfoncés </strong>ou <strong>relâchés</strong>) fonctionnent tous sur le masque de l'instance qui a l'événement. Cela signifie que <span data-keyref="GameMaker Name">GameMaker</span> va vérifier la position de la souris dans la pièce lorsque ces boutons sont utilisés par rapport aux masques de collision des instances qui ont un événement souris. S'il y a une &quot;collision&quot; avec le <a class="glossterm" data-glossterm="boîte de délimitation" href="#">rectangle de délimitation de l'</a> instance, l'événement sera déclenché. Assurez-vous donc que toute instance présentant ces événements possède un <span class="notranslate">sprite</span> avec un masque de collision valide ou que l'objet possède un masque <span class="notranslate">sprite</span> sélectionné dans les propriétés de l'objet. Comme leur nom l'indique, ces événements seront déclenchés soit une fois, lorsque le bouton de la souris choisi est enfoncé ou relâché pour la première fois, soit en continu à chaque étape tant que le bouton est maintenu. </p>
      <p class="dropspot">Les événements d'entrée et de sortie de la souris sont également similaires aux événements de bouton dans la mesure où ils dépendent également du masque de l'instance pour fonctionner, mais cette fois-ci, ils sont déclenchés lorsque la souris &quot;entre&quot; (touche) l'instance pour la première fois ou lorsque la souris &quot;sort&quot; (cesse de toucher) l'instance. Ces événements ne sont toutefois pas continus et ne sont déclenchés qu'une seule fois à chaque fois que la souris entre ou sort de l'objet. Ils constituent donc une méthode idéale pour créer, par exemple, des boutons qui doivent changer lorsque la souris les survole avant de revenir à la normale lorsque la souris est retirée.</p>
      <p class="dropspot">Enfin, nous avons une autre section pour les événements de la souris, appelée <strong>Souris globale</strong>. Dans ce sous-menu, vous trouverez une sélection d'événements permettant d'enregistrer les événements de souris dans les instances, même si la souris n'est pas au-dessus ou à proximité de celles-ci. Ces événements sont générés pour <em>toutes les </em>instances et si des actions ou du code sont définis pour l'événement spécifié, ils seront exécutés, quelle que soit la position de la souris dans la salle de jeu.</p>
      <p class="dropspot">Veuillez noter que sur les appareils mobiles ou à écran tactile, le bouton gauche de la souris <img> peut également être utilisé pour vérifier la présence d'un doigt sur un écran tactile, et le bouton droit de la souris <img> est déclenché par une double tape sur l'écran (ce comportement peut être modifié à l'aide d'un code).</p>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down18" href="#">Gestes</a></p>
    <div class="droptext" data-targetname="drop-down18">
      <p class="dropspot">Cet événement est celui qui sera déclenché lorsque l'utilisateur touchera l'écran (sur mobile) ou cliquera et déplacera la souris (sur toutes les autres plateformes). Ces événements sont similaires à ceux de la souris, en ce sens qu'il existe des versions régulières et des versions <em>globales</em>. Les versions normales de ces événements ne sont déclenchées que lorsque les contacts se produisent sur une instance qui possède un <span class="notranslate">sprite</span> (ou un masque) et que les contacts se produisent dans sa <a class="glossterm" data-glossterm="boîte de délimitation" href="#">boîte de délimitation</a>. Les versions globales de ces événements, en revanche, seront déclenchées si l'utilisateur touche <em>n'importe quel endroit </em>de l'écran.</p>
      <p class="dropspot">Les événements gestuels détectent les éléments suivants :</p>
      <ul class="dropspotlist">
        <li class="dropspot"><img> <strong>tapotements - </strong> lorsqu'un utilisateur clique/touche et relâche rapidement la pression.</li>
        <li class="dropspot"><img> <strong>glisser - </strong> lorsqu'un utilisateur touche/clique et maintient son doigt/curseur, puis le déplace.</li>
        <li class="dropspot"><img> <strong>flicks - </strong> lorsque l'utilisateur déplace et relâche une touche/clic en un seul mouvement</li>
        <li class="dropspot"><img> <strong>pincements - </strong> lorsque l'utilisateur a deux doigts sur l'écran et qu'il les rapproche ou les écarte.</li>
        <li class="dropspot"><img> <strong>Rotation - </strong> lorsque l'utilisateur place deux doigts sur l'écran et les fait pivoter autour d'un point.</li>
      </ul>
      <p class="dropspot"><img>Les différents événements contiendront toujours une carte DS appelée carte &quot;<span class="inline">event_data</span>&quot;, qui contiendra un certain nombre de paires clé/valeur contenant des données sur la position et le mouvement du toucher/clic. Pour plus de détails sur tous les sous-événements disponibles et leur fonctionnement, veuillez consulter la section suivante :</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Gesture_Events.htm">L'événement Gesture</a></li>
      </ul>
      <p class="dropspot"> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down19" href="#">Autre</a></p>
    <div class="droptext" data-targetname="drop-down19">
      <p class="dropspot">Il existe un certain nombre d'événements spéciaux à utiliser lors de la création de jeux avec <span data-keyref="GameMaker Name">GameMaker</span>. Ils sont pour la plupart regroupés sous l'événement Other et peuvent être sélectionnés dans le menu contextuel des sous-événements qui s'affiche lorsque vous sélectionnez cet événement. Voici une image de tous ces autres événements :</p>
      <p class="dropspot"><img>Pour plus d'informations sur chacun des événements figurant dans l'image ci-dessus, veuillez consulter la section suivante :</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Other_Events.htm">Les autres événements</a></li>
      </ul>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down20" href="#">Dessinez</a></p>
    <div class="droptext" data-targetname="drop-down20">
      <p class="dropspot">Cette catégorie d'événement est celle qui régit ce que vous voyez à l'écran lorsque vous exécutez votre jeu, et elle est divisée en plusieurs événements discrets :</p>
      <p class="dropspot"><img>Comme vous pouvez le constater, la catégorie des événements de dessin comporte plusieurs types d'événements différents. <strong>Draw Begin</strong>, <strong>Draw </strong>et <strong>Draw End</strong> sont les événements de dessin &quot;standard&quot; que vous utiliserez probablement le plus. Par défaut, l'événement principal Draw est toujours appelé pour chaque instance, qu'elle dispose ou non d'une <span class="notranslate">sprite</span>. Cependant, si vous marquez l'instance comme invisible, l'événement ne sera pas déclenché (gardez cela à l'esprit si vous avez une logique de jeu dans l'événement Draw d'un objet invisible, car elle ne s'exécutera pas). L'événement de dessin principal est également l'endroit où <span data-keyref="GameMaker Name">GameMaker</span> dessine par défaut l'instance <span class="notranslate">sprite</span> lorsqu'il n'y a ni code ni action dans l'événement (c'est-à-dire que vous ne l'avez pas ajouté dans la liste des événements de l'objet). Le dessin par défaut utilise le site <span class="notranslate">sprite</span> associé à l'instance et le dessinera avec toutes les transformations définies dans le code ou les actions appliquées.</p>
      <p class="dropspot">Les événements de dessin standard dessinent <em>avant </em>les événements <strong>Draw GUI </strong>et <em>entre les </em>événements <strong>Pre Draw </strong>et <strong>Post Draw </strong>, ce qui signifie que tout ce qui est dessiné dans cet événement est dessiné sous celui de l'événement <strong>Draw GUI </strong>, quelle que soit la couche (c'est-à-dire que tout ce qui est dessiné dans l'événement Draw GUI sera toujours dessiné par-dessus tout ce qui est dessiné dans l'événement de dessin normal, quel que soit l'ordre des couches).</p>
      <p class="dropspot">Notez que ce qui précède n'est qu'une vue d'ensemble du fonctionnement des événements de tirage au sort, mais pour des détails complets sur tous les sous-événements disponibles, veuillez consulter la section suivante :</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Draw_Events.htm">L'événement du tirage au sort</a></li>
      </ul>
      <p> </p>
      <p> </p>
      <p class="dropspot"> </p>
    </div>
    <p><img><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down21" href="#">Asynchrone</a></p>
    <div class="droptext" data-targetname="drop-down21">
      <p class="dropspot">Cette catégorie d'événements est particulière dans la mesure où les événements qu'elle contient ne sont pas déclenchés par défaut par <span data-keyref="GameMaker Name">GameMaker</span>, mais plutôt par la fin d'une autre action, comme le chargement d'un fichier ou la réponse d'un serveur web. La catégorie est divisée en plusieurs événements :</p>
      <p class="dropspot"><img alt="Object Editor Events View" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_Events.png"/></p>
      <p class="dropspot">Disons que vous voulez ajouter un fichier image à <span data-keyref="GameMaker Name">GameMaker</span>. Vous pourriez coder cette opération dans un autre événement (peut-être l'événement de création) d'un objet, puis faire en sorte que cet objet dessine une barre de chargement en attendant (par exemple), en interrogeant l'événement asynchrone approprié jusqu'au <a class="glossterm" data-glossterm="rappel" href="#">rappel</a> qui indique à <span data-keyref="GameMaker Name">GameMaker</span> que le fichier est chargé. Vous pouvez ensuite utiliser les données renvoyées dans cet événement pour faire d'autres choses, comme changer de pièce ou acheter un objet.</p>
      <p class="dropspot">Notez que ce qui précède n'est qu'une vue d'ensemble du fonctionnement de l'événement asynchrone, mais pour des détails complets sur tous les sous-événements disponibles, veuillez consulter la section suivante :</p>
      <ul class="dropspotlist">
        <li class="dropspot"><a href="Async_Events.htm">Liste des événements asynchrones</a></li>
      </ul>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p>Vous devez également noter que vous pouvez nommer les événements, ou du moins leur donner un court texte descriptif qui sera affiché à côté d'eux dans l'éditeur d'événements. Pour ce faire, il suffit d'ajouter le texte suivant dans la toute première ligne de l'éditeur de code de l'événement (lorsque vous utilisez le <span data-keyref="GML_Code">code GML</span>) :</p>
    <p class="code">/// @description Your text here</p>
    <p>Ainsi, vous pourriez avoir quelque chose comme ceci dans - par exemple - un événement d'<strong>alarme </strong>:</p>
    <p class="code">/// @description This is the AI Fight alarm</p>
    <p>Et maintenant, dans votre éditeur d'événements, vous verrez ceci :</p>
    <p><img alt="Object Editor Events List" class="center" src="../../assets/Images/Asset_Editors/Editor_Objects_EventList.png"/></p>
    <p>Pour les utilisateurs de <span data-keyref="GML_Visual">GML Visual</span>, l'ajout d'un commentaire nécessite l'utilisation de l'action <strong>Execute Code</strong>, qui doit être placée tout en haut des actions de l'événement, avant tout le reste. Lorsque vous ajoutez cette action, vous lui donnez ensuite la même ligne de code que celle indiquée ci-dessus pour nommer l'événement, par ex :</p>
    <p><img>Pour plus d'informations sur certains des événements ci-dessus et sur le déroulement général des événements, veuillez consulter les sections suivantes :</p>
    <ul class="colour">
      <li><a href="Event_Order.htm">Ordre des événements</a></li>
      <li><a href="Other_Events.htm">Les autres événements</a></li>
      <li><a href="Draw_Events.htm">Les événements du tirage au sort</a></li>
      <li><a href="Async_Events.htm">Les événements asynchrones</a></li>
      <li><a href="Gesture_Events.htm">Les événements du geste</a></li>
    </ul>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Retour : <a href="../Objects.htm">L'éditeur d'objets</a></div>
          <div style="float:right">Suivant : Objets parents</div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tous droits réservés</span></h5>
    </div>
    <!-- KEYWORDS
Object Events
Named Events
--><!-- TAGS
object_events
--></body>
</html>