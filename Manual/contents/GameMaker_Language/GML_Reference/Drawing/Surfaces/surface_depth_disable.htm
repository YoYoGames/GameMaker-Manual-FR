<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>surface_depth_disable</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <script src="../../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference for surface_depth_disable" />
  <meta name="rh-index-keywords" content="surface_depth_disable" />
  <meta name="search-keywords" content="surface_depth_disable" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>surface_depth_disable</h1>
  <p>Cette fonction désactive la génération automatique de la profondeur <span class="notranslate">buffer</span> pour <i>toutes les</i> surfaces qui sont créées après qu'elle ait été désactivée. Normalement, toutes les surfaces ont une profondeur <span class="notranslate">buffers</span>, donc si vous y dessinez des objets 3D, ils seront triés correctement par profondeur afin de maintenir la parité fonctionnelle entre le rendu sur les surfaces et le rendu au dos.
    afin de maintenir la parité fonctionnelle entre le rendu sur les surfaces et le rendu à l'arrière <span class="notranslate">buffer</span>, cependant l'allocation de la profondeur <span class="notranslate">buffers</span> double essentiellement la quantité de mémoire requise pour les surfaces, ce qui pourrait être une surcharge excessive et inutile
    surtout si votre jeu est très gourmand en mémoire, et pour les jeux 2D, elles ne sont généralement pas nécessaires.</p>
  <p>Pour utiliser cette fonction, vous devez l'appeler <i>avant de</i> créer une surface, puis vous pouvez l'activer à nouveau après (si nécessaire). Toutes les surfaces créées lorsque la profondeur <span class="notranslate">buffer</span> est désactivée n'utiliseront plus la profondeur <span class="notranslate">buffer</span> lorsqu'elles seront dessinées.
    les objets dessinés sur la surface ont une parité de profondeur. Les images ci-dessous illustrent cela en pratique :</p>
  <p><img>Dans l'image ci-dessus, nous dessinons un rectangle et un triangle en utilisant un vertex <span class="notranslate">buffer</span> en 3D. Les coordonnées
    pour le triangle rouge le place derrière le rectangle vert, mais le code pour dessiner le triangle est appelé <i>après le</i> code pour le rectangle, et lorsque la profondeur <span class="notranslate">buffer</span> est activée, le triangle est toujours dessiné derrière le rectangle car la profondeur 3D est respectée.
    car la profondeur 3D est respectée. Cependant, lorsque nous désactivons la profondeur <span class="notranslate">buffer</span> pour la surface, seul l'ordre du code est respecté et le triangle est donc dessiné au-dessus du rectangle.</p>
  <p class="note"><b>REMARQUE</b>: pour préserver correctement la profondeur en 3D lors de l'utilisation de surfaces, il faut non seulement activer la profondeur <span class="notranslate">buffer</span>, mais aussi activer l'écriture en z et le test en z. Voir les fonctions <a href="../GPU_Control/gpu_get_ztestenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_ztestenable()</span></a>    et <a href="../GPU_Control/gpu_get_zwriteenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_zwriteenable()</span></a> pour plus d'informations.</p>
  <p class="note"><b>REMARQUE</b>: si votre jeu est 100 % 2D ou si vous savez que vous n'avez pas besoin d'une profondeur de surface <span class="notranslate">buffer</span>, il devrait être possible d'appeler cette fonction une fois au début du jeu pour désactiver le <span class="notranslate">buffer</span>.</p>
  <p> </p>
  <h4>Syntaxe :</h4>
  <p class="code">surface_depth_disable(disable);</p>
  <table>
    <tbody>
      <tr>
        <th>Arguments</th><th>Type</th>
        <th>Description</th>
     </tr>
      <tr>
        <td><span class="notranslate">disable</span></td><td><span data-keyref="Type_Bool"></span></td>
        <td><span class="notranslate">If set to <span class="inline">true</span> le tampon de profondeur sera désactivé pour les surfaces créées.</td>
     </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Les retours :</h4>
  <p class="code"><span data-keyref="Type_Void"></span></p>
  <p> </p>
  <h4>Exemple :</h4>
  <p class="code">var _depth_setting = surface_get_depth_disable();<br/> surface_depth_disable(false);
    <br/> surface_with_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(true);
    <br/> surface_without_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(_depth_setting);
  </p>
  <p>Le code ci-dessus stocke le paramètre actuel de la profondeur <span class="notranslate">buffer</span> dans une variable, puis crée deux surfaces, l'une avec la mise en mémoire tampon de la profondeur activée et l'autre sans, avant de rétablir à nouveau le paramètre original.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="Surfaces.htm">Surfaces</a></div>
        <div style="float:right">Suivant : <a href="surface_get_height.htm"><span class="notranslate">surface_get_height</span></a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
surface_depth_disable
-->
  <!-- TAGS
surface_depth_disable
-->
</body>
</html>