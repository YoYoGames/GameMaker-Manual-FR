<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mots clés de l'instance</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Mots clés de l'instance</h1>
    <p>Pour faciliter certaines choses dans <span data-keyref="GameMaker Name">GameMaker</span>, vous pouvez utiliser l'un des nombreux <b>mots-clés d'instance</b> dans votre code (que ce soit <span class="notranslate">GML</span> ou <span class="notranslate">GML</span> Visual). Ces mots-clés sont principalement utilisés pour identifier les instances - et dans certains cas <span class="notranslate">structs</span> - dans différentes situations, et chacun d'entre eux est expliqué dans le texte ci-dessous.</p>
    <p>Notez que tous les mots-clés donnés sont représentés par des <strong>valeurs entières négatives</strong> en interne, il faut donc faire attention lorsque vous assignez ou vérifiez des valeurs de variables par rapport à ces mots-clés, car vous pourriez obtenir des résultats inattendus par la suite, <span data-keyref="GameMaker Name">GameMaker</span> interprétant la valeur que vous avez utilisée comme autre chose. Vous devez également noter que l'utilisation des valeurs entières directement à la place des mots-clés dans votre code <b>n'</b> est <b>pas du tout recommandée</b> et pourrait causer des problèmes plus tard.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Mot clé</th>
            <th>Description</th>
            <th>valeur</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>L'instance/structure qui exécute le bloc de code actuel.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> peut être utilisé pour identifier le site <span class="notranslate">struct</span> ou l'instance en cours dans le bloc de code actuel. Par exemple :</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">Dans cet exemple, vous pouvez voir que nous avons une variable <i>locale</i> appelée <span class="inline">val</span> et que nous voulons qu'elle définisse la variable d'<i>instance</i> portant le même nom dans l'instance d'objet nouvellement créée. Pour identifier correctement la variable d'instance et dire à <span data-keyref="GameMaker Name">GameMaker</span> de la définir dans l'instance appelant le bloc de code, nous utilisons le mot-clé <span class="inline">self</span>. Dans la plupart des cas, vous pouvez également utiliser la variable d'instance intégrée <span class="inline">id</span> au lieu de <span class="inline">self</span>, mais <span class="inline">self</span> offre certains avantages. Tout d'abord, il est plus rapide pour le compilateur d'identifier l'instance (ou <span class="notranslate">struct</span>) en utilisant <span class="inline">self</span> plutôt que <span class="inline">id</span>, car la valeur <span class="inline">id</span> passe par la table de recherche d'instance alors que <span class="inline">self</span> ne le fait pas. Deuxièmement, pour les personnes qui créent des extensions, il est très utile d'assurer la portée correcte des variables, car il est possible qu'un projet qui utilise une extension ait une variable de portée globale ou quelque chose avec le même nom qu'une variable dans l'extension.</p>
      <p class="note"><strong>NOTE</strong>: Le mot-clé <span class="inline">self</span> <strong>n'</strong>est <strong>pas </strong>un raccourci pour la valeur réelle de l'ID d'une instance ou <span class="notranslate">struct</span> et ne doit être utilisé que dans le contexte expliqué ci-dessus. Si vous avez besoin de la <strong>valeur d'</strong>identification d'une instance, vous devez utiliser <span class="inline">self.id</span>, par exemple :</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">Il convient également de noter que <span class="inline">self</span> peut également être utilisé à l'intérieur de <a href="Structs.htm">structs</a> - dans des circonstances très spécifiques - pour référencer des variables membres pour le <span class="notranslate">struct</span>.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Mot clé</th>
            <th>Description</th>
            <th>valeur</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>L'autre instance impliquée dans un événement de collision, dans une fonction <span class="inline">with</span> ou dans une fonction.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Le mot-clé spécial <span class="inline">other</span> peut être utilisé de plusieurs façons pour référencer une instance spécifique (et dans certains cas, une <span class="notranslate">struct</span>) : il peut être utilisé dans une déclaration <span class="inline">with</span> (expliquée <a href="Language_Features/with.htm">ici</a>), dans un <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">événement de collision</a> ou dans une fonction. Cette section va expliquer les deux derniers cas d'utilisation.</p>
      <p class="dropspot">Notez que dans les événements autres que l'événement de collision, en dehors de tout appel de fonction et des blocs <span class="inline">with()</span>, <span class="inline">other</span> renvoie simplement le <span class="notranslate">struct</span> de l'instance actuelle.</p>
      <h2 class="dropspot">Événement de collision</h2>
      <p class="dropspot">Un événement de collision ne peut se produire qu'entre <strong>deux </strong>instances. Vous <i>pouvez</i> avoir plusieurs collisions entre plusieurs instances, mais elles sont toutes résolues par <span data-keyref="GameMaker Name">GameMaker</span> sur une base individuelle, avec l'instance &quot;soi&quot; qui a l'événement de collision et l'instance &quot;autre&quot; qui entre en collision avec elle.</p>
      <p class="dropspot">Imaginez que vous ayez une instance de joueur, plusieurs instances d'ennemis et plusieurs instances de balles que l'ennemi peut vous tirer dessus. Vous pouvez attribuer à chaque ennemi une seule instance de balle, mais avec une variable de dégâts différente qui lui est attribuée aléatoirement lors de sa création, par exemple :</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Vous pouvez voir comment nous définissons ses variables à l'aide de la notation par points, comme indiqué dans la section sur l'<a href="Addressing_Variables_In_Other_Instances.htm">adressage des variables dans d'autres instances</a>. Cela donnera à chaque instance de balle une valeur de dégâts différente, mais comment le joueur détectera-t-il les dégâts qu'il doit subir lorsqu'il est touché par une balle ?</p>
      <p class="dropspot">Pour cela, le joueur devra avoir un événement de collision avec <span class="inline">obj_Bullet</span>, et dans cet événement, utiliser <span class="inline">other</span> pour lire les variables de l'instance de balle en collision :</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">Le code ci-dessus déduira le montant stocké dans la variable &quot;damage&quot; de l'<i>autre</i> instance de la variable &quot;hp&quot; du joueur, puis il vérifiera si le &quot;hp&quot; est inférieur ou égal à 0. Si c'est le cas, il détruira l'instance du joueur. Veuillez noter que l'autre instance doit posséder la variable à vérifier, sinon une erreur sera générée.</p>
      <p class="note"><strong>REMARQUE</strong>: l'événement Collision est le seul événement qui a une signification particulière pour le mot-clé <span class="inline">other</span>. Dans tous les autres événements et scripts, le comportement de <span class="inline">other</span> sera défini par le contexte dans lequel il est utilisé (par exemple, un bloc <span class="inline">with() </span>, une fonction, une déclaration <span class="notranslate">struct</span>, etc.)</p>
      <p class="dropspot">Vous pouvez attribuer des valeurs aux variables, ou même en créer de nouvelles, en utilisant <span class="inline">other</span> dans l'événement de collision, comme ceci :</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Déclaration de structure</h2>
      <p class="dropspot">Lorsqu'il est utilisé à l'intérieur d'une déclaration <span class="notranslate">struct</span>, <span class="inline">other</span> fait référence à l'instance qui initialise la structure :</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Cependant, vous n'avez pas besoin d'utiliser <span class="inline">other</span> pour lire les variables de l'instance car toutes les variables auxquelles vous faites référence directement seront lues depuis la portée de cette instance, comme décrit <a href="Structs.htm#inst_in_struct">dans cette section</a> du manuel. Vous n'aurez besoin de l'utiliser que si vous souhaitez stocker une référence à l'adresse <span class="notranslate">struct</span> de cette instance.</p>
      <h2 class="dropspot">Méthode d'instance</h2>
      <p class="dropspot">L'utilisation de <span class="inline">other</span> au sein d'une autre instance <a href="Method_Variables.htm"><span class="notranslate">method</span></a> fait référence à l'instance qui a appelé cette méthode.</p>
      <p class="dropspot">Par exemple, disons que <span class="inline">Object2</span> a une méthode qui fait référence à <span class="inline">self</span> et <span class="inline">other</span>. Cette méthode est ensuite appelée dans <span class="inline">Object1</span>. Puisque la méthode a été créée dans <span class="inline">Object2</span>, elle est <strong>liée</strong> à celle-ci et utilisera toujours l'instance <span class="inline">Object2</span> comme &quot;self&quot;, quelle que soit l'instance qui l'appelle. Dans ce cas, l'instance appelante devient <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Ainsi, l'instance imprimerait d'abord son propre nom d'objet (&quot;Object2&quot;), puis le nom d'objet de l'instance appelante (&quot;Object1&quot;).</p>
      <p class="dropspot">Il en va de même pour une méthode qui est liée à un <span class="notranslate">struct</span>.</p>
      <h2 class="dropspot">Fonction Constructeur</h2>
      <p class="dropspot">Lorsqu'il est utilisé au sein d'une fonction de construction, <span class="inline">other</span> fera référence à l'instance qui appelle cette fonction. Toutefois, cela n'est pas recommandé pour une utilisation générale, car toutes les données externes qu'un constructeur doit utiliser doivent être passées en argument.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Mot clé</th>
            <th>Description</th>
            <th>valeur</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Toutes les instances actuellement actives dans la salle.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Ce mot-clé est utilisé pour indiquer à <span data-keyref="GameMaker Name">GameMaker</span> qu'une fonction doit être appliquée, ou pour vérifier, toutes les instances actives d'une room (les instances désactivées ne seront pas vérifiées ou accédées). Vous <b>ne pouvez pas</b> utiliser <span class="inline">all</span> pour <span class="notranslate">access</span> ou définir des variables dans d'autres instances en utilisant la méthode du point (voir <a href="Addressing_Variables_In_Other_Instances.htm">ici</a>), mais vous <strong>pouvez </strong>l'utiliser lors de l'appel de la fonction <a href="Language_Features/with.htm"><span class="inline">with()</span></a>par exemple :</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">Le code ci-dessus réglera la vitesse de toutes les instances de la pièce sur 0. Vous pouvez également utiliser <span class="inline">all</span> dans les fonctions pour cibler ou vérifier toutes les instances de la pièce, par exemple :</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> est un mot-clé très utile et peut être utilisé dans de nombreuses situations dans votre code et vos actions, réduisant souvent la quantité de code que vous devez écrire pour obtenir un effet désiré.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Mot clé</th>
            <th>Description</th>
            <th>valeur</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>Aucune instance du tout.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Cela peut sembler étrange, mais souvent, en programmant vos jeux, vous aurez besoin de vérifier si aucune instance n'a été trouvée à un endroit, ou dans une collision, etc... Dans ces cas, vous utiliserez ce mot-clé pour vérifier qu'il n'y a rien, quelque chose comme ceci :</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">Dans cet exemple, la fonction <span class="inline">instance_nearest()</span> renverra soit <span class="inline">noone</span>, soit l'ID unique de l'instance trouvée la plus proche. En fait, chaque fois que vous avez besoin de vérifier la présence d'une instance, vous pouvez vous attendre à obtenir soit <span class="inline">noone</span>, soit un ID d'instance unique.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Retour : <a href="GML_Overview.htm">Aperçu du GML</a></div>
          <div style="float:right">Suivant : <a data-xref="{title}" href="Evaluation_Order.htm">Ordre d'évaluation</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tous droits réservés</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>