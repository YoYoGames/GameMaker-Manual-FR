<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Tableaux</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Tableaux</h1>
  <p>Les tableaux peuvent être extrêmement utiles et constituent un élément essentiel de la création de jeux. Il s'agit essentiellement d'un type de variable qui peut contenir plusieurs valeurs sous forme de &quot;liste&quot; -- considérez le code suivant :</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>En utilisant la syntaxe <span class="inline2">[item, item, item]</span>, nous créons un tableau qui est stocké dans une variable. Il est possible d'accéder ultérieurement aux éléments stockés dans un tableau par le biais de cette variable en utilisant un nombre entier, commençant par <span class="inline">0</span>, qui est placé entre crochets <span class="inline2">[]</span>:</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">Un tableau de base est classé comme ayant une <strong>dimension</strong>, mais vous pouvez également avoir des tableaux avec plus d'une dimension. Les sections ci-dessous expliquent les deux types de tableaux :</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Tableaux à 1 dimension</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Avant d'aller plus loin, précisons ce qu'est un tableau et comment il est structuré. Un tableau est simplement un <a href="Data_Types.htm">type de données</a> qui est assigné à une variable, et il peut contenir non seulement une valeur, mais plusieurs valeurs. L'image ci-dessous montre le schéma d'un tableau de base :</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">Cela s'appelle un tableau <strong>1D</strong> (unidimensionnel) et, comme vous pouvez le voir, le tableau est stocké dans la variable &quot;<span class="inline">a</span>&quot; et contient plusieurs valeurs. Pour <span class="notranslate">access</span> le tableau, vous devez faire quelque chose comme ce qui suit :</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">Le code ci-dessus récupère la valeur de la position 0 du tableau &quot;<span class="inline">a</span>&quot; puis l'envoie à la console, qui - sur la base du contenu du tableau montré dans l'image ci-dessus - devrait afficher 125. Si vous faites ce qui suit :</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">La sortie indiquerait &quot;Salut !&quot;.</p>
    <p class="dropspot">Comme vous pouvez le voir, vous donnez au tableau un nom de variable, puis une valeur entre crochets <span class="inline">[]</span>, où la valeur est la position dans le tableau d'où proviennent les données. Ainsi, un tableau est essentiellement un conteneur avec un certain nombre d'emplacements pour stocker des valeurs, et chaque position dans le conteneur a un numéro spécifique pour l'identifier, qui est ce que nous mettons dans le <span class="inline">[]</span>. Il est intéressant de noter que le contenu d'un tableau <b>commence toujours à 0</b> et <i>ne peut jamais être négatif</i><em>!</em></p>
    <h3 class="dropspot">       Création de tableaux</h3>
    <p class="dropspot">Nous avons montré comment vérifier la présence de données dans un tableau, mais comment créer le tableau pour commencer ? Il faut d'abord l'<i>initialiser</i> avant de pouvoir l'utiliser, sinon <span data-keyref="GameMaker Name">GameMaker</span> nous enverra une erreur. Initialiser un tableau signifie simplement que nous donnons à chaque emplacement du tableau une valeur initiale en vue de son utilisation ultérieure dans le code du projet. Il est important de s'en souvenir car cela signifie que vous devez faire un peu de planification avant d'utiliser des tableaux, mais il est assez facile d'en initialiser un en utilisant une boucle répétitive comme celle-ci :</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">Ce code simple initialisera un tableau de dix cases (de 0 à 9) pour contenir 0, c'est-à-dire que chaque case du tableau contient la valeur 0. Vous remarquerez que le tableau a été initialisé <i>à l'envers</i>, la dernière valeur étant définie en premier. Ce n'est pas strictement nécessaire, mais c'est la façon optimale de procéder, car cela permet de réserver un espace en mémoire qui correspond à la taille exacte du tableau, alors que si vous initialisez un tableau à <em>partir</em> de 0, la mémoire doit être réallouée pour chaque valeur supplémentaire ajoutée (ainsi, pour un tableau à dix emplacements, l'initialiser dans une boucle modifierait l'allocation de mémoire dix fois). La différence de vitesse est négligeable pour les petits tableaux, mais les tableaux plus grands devraient être optimisés autant que possible de cette manière.</p>
    <p class="note"><b>REMARQUE</b>: L'exportation HTML5 est l'exception à la règle ci-dessus, et lorsque vous ciblez cette cible, vous devez initialiser les tableaux dans un ordre consécutif à partir de 0.</p>
    <p class="dropspot">Vous pouvez également utiliser la fonction <span class="notranslate">GML</span> <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> pour initialiser un tableau avec une taille fixe, et vous pouvez même créer des tableaux &quot;vides&quot; <em>sans</em> valeur, par exemple :</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">Cela indique à <span class="notranslate">GameMaker</span> que la variable &quot;<span class="inline">my_array</span>&quot; est un tableau, et que vous pouvez donc y <a href="../GML_Reference/Variable_Functions/array_push.htm">ajouter des valeurs</a> à tout moment. Cependant, si vous essayez d'envoyer une valeur à <span class="notranslate">access</span> dans un tableau vide, vous obtiendrez une erreur.<br /></p>
    <p class="dropspot">Si vous savez déjà quels éléments vous voulez mettre dans le tableau, vous pouvez ajouter des valeurs séparées par des virgules entre les parenthèses lors de la déclaration du tableau :</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       Limites des tableaux</h3>
    <p class="dropspot"> <span class="notranslate">access</span> Vous devez toujours faire attention à n'utiliser que des positions de tableau valides, car essayer d'utiliser <span class="notranslate">access</span> une valeur en dehors d'un tableau entraînera également une erreur. Par exemple, cela provoquera un crash du projet lors de son exécution :</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">Le tableau n'a été initialisé qu'avec 5 positions, mais nous avons essayé d'obtenir la position 7 - puisque les tableaux sont numérotés à partir de 0, <span class="inline">array[6]</span> est la position 7 - par conséquent le jeu génère une erreur et se plante.</p>
    <h3 class="dropspot">       Utilisation des tableaux</h3>
    <p class="dropspot">Maintenant, comment utiliser un tableau de manière pratique ? Exactement de la même manière que nous utiliserions une variable normale, comme le montrent les exemples suivants :</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if (array[9] == 10)<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">Comme les tableaux sont numérotés de manière séquentielle, cela signifie que vous pouvez les parcourir en boucle pour effectuer des actions supplémentaires, comme nous l'avons fait pour les initialiser :</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          _total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), _total);
    </p>
    <p class="dropspot">Le code ci-dessus va additionner toutes les valeurs de notre tableau, dessiner chacune d'entre elles, puis dessiner la valeur totale à la fin.</p>
    <h3 class="dropspot">       Suppression des tableaux</h3>
    <p class="dropspot">La dernière chose à mentionner à propos des tableaux est que vous pouvez supprimer un tableau simplement en &quot;réassignant&quot; la variable qui le définit à une valeur unique. Cela libérera la mémoire associée à toutes les positions et valeurs de ce tableau. Par exemple :</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = undefined;
    </p>
    <p class="dropspot">Si le tableau a plusieurs dimensions (voir ci-dessous), elles seront toutes nettoyées également. Notez que lorsque vous créez des tableaux dans des instances, ils n'ont pas besoin d'être nettoyés lorsque l'instance est retirée du jeu, car ils seront automatiquement supprimés par le <a class="glossterm" data-glossterm="éboueur" href="#">garbage collector</a> lors de la destruction ou de la fin de la room. Cependant, si l'une des positions du tableau contient des références à des ressources <em>dynamiques</em>, telles que des systèmes de particules, <span class="notranslate">buffers</span>, ou des structures de données, celles-ci <em>devront</em> être détruites avant que le tableau ne soit supprimé, l'instance détruite ou la pièce terminée.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Tableaux multidimensionnels</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">Nous savons maintenant ce qu'est un tableau à une dimension, mais dans <span data-keyref="GameMaker Name">GameMaker</span>, vous pouvez avoir des tableaux à plusieurs dimensions, qui sont essentiellement structurés comme un tableau dans un tableau dans un tableau... Par exemple, le tableau suivant est un tableau <strong>2D</strong> (à deux dimensions) :</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">Cela revient à dire à <span class="notranslate">GameMaker</span> que le tableau est en fait composé de plusieurs tableaux 1D. Voici un exemple détaillé :</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">Dans le code ci-dessus, <span class="inline">array[0]</span> contient un autre tableau, de même que <span class="inline">array[1]</span>.</p>
    <p class="dropspot">Un tableau multidimensionnel doit être initialisé avant d'être utilisé, de la même manière qu'un tableau simple à 1D, et peut contenir des nombres réels, des chaînes de caractères et tout autre <a href="Data_Types.htm">type de données</a>, comme n'importe quelle variable, ce qui en fait des candidats idéaux pour tout jeu qui a besoin de stocker de grandes quantités de données d'une manière facilement accessible (n'oubliez pas que vous pouvez facilement boucler dans un tableau).</p>
    <p class="dropspot">Vous pouvez également initialiser un tableau multidimensionnel dans une seule instruction en imbriquant des tableaux à une dimension :</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">Les tableaux multidimensionnels ne sont pas non plus limités <em>à </em>deux dimensions, et vous pouvez avoir 3, 4 ou plus de dimensions à un tableau selon les besoins de votre code, en ajoutant simplement <span class="inline">[n]</span> arguments supplémentaires, par exemple :</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">Il convient également de noter que la longueur de chaque dimension d'un tableau peut être différente. Ainsi, la dimension initiale du tableau peut avoir une longueur de 3, mais l'entrée de la deuxième dimension peut avoir une longueur différente pour chaque emplacement de la première dimension ; par exemple :</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">Dans le code ci-dessus, <span class="inline">array[0]</span> a 2 slots, <span class="inline">array[1]</span> a 4 slots et <span class="inline">array[2]</span> a 3 slots.</p>
    <h3 class="dropspot">       Exemple étendu</h3>
    <p class="dropspot">Voici un dernier exemple d'utilisation dans un jeu réel : Disons que vous voulez faire apparaître quatre ennemis différents à quatre moments différents de votre jeu en fonction d'une valeur aléatoire. Eh bien, nous pouvons utiliser un tableau à 2 dimensions pour le faire et éviter d'écrire une grande quantité de code.</p>
    <p class="dropspot">Tout d'abord, nous devons initialiser le tableau que nous allons utiliser dans l'événement Create de notre objet &quot;contrôleur&quot; (notez l'utilisation de commentaires pour vous rappeler ce que fait chaque entrée du tableau) :</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">Nous avons maintenant les objets pour créer des instances et leurs coordonnées x et y correspondantes dans la pièce, le tout stocké dans notre tableau. Ceci peut maintenant être utilisé comme suit dans un autre événement de l'objet contrôleur (une alarme par exemple, ou un événement de pression de touche) :</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">Ce court code va maintenant faire apparaître un ennemi aléatoire dans la salle de jeu, et il utilise beaucoup moins de code qu'une structure &quot;<span class="inline">if / then / else</span>&quot; ou même &quot;<span class="inline">switch</span>&quot;, et comme le tableau est initialisé dans l'événement de création, il est BEAUCOUP plus facile d'éditer et de modifier ces valeurs car elles ne sont pas <a class="glossterm" data-glossterm="codé en dur" href="#">codées en dur</a> dans le reste du code du projet.</p>
  </div>
  <p> </p>
  <h2>Les tableaux comme arguments de fonction</h2>
  <p>Vous pouvez passer des tableaux dans les <a href="Script_Functions.htm">fonctions de script</a> et les <a href="Method_Variables.htm">variables de méthode</a> comme arguments, et modifier ces tableaux n'importe où dans la fonction. Ce faisant, les tableaux d'origine seront également modifiés.</p>
  <p>Par exemple, cette fonction modifie simplement les trois premiers éléments du tableau qui lui est passé :</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>Vous pouvez maintenant créer un tableau et le passer dans cette fonction, qui modifiera le tableau :</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>Dans les versions précédentes de <span class="notranslate">GameMaker</span>, ce n'était pas le cas, car la modification d'un tableau à l'intérieur d'une fonction créait une copie à la place. Ce comportement <em>déprécié</em> peut toujours être activé si vous le souhaitez : lisez la section &quot;<strong>Copy on Write</strong>&quot; ci-dessous pour plus d'informations.</p>
  <h2 id="h">Copier sur écrire</h2>
  <p>Le comportement de copie en écriture est obsolète et n'est utilisé que lorsque l'option &quot;<strong>Activer le comportement de copie en écriture pour les tableaux</strong>&quot; est activée dans les <a href="../../Settings/Game_Options.htm">options générales du jeu</a>. Cette section décrit le comportement des tableaux lorsque cette option est activée.</p>
  <p>Comme décrit dans la section précédente, les tableaux peuvent être passés aux fonctions comme arguments. Pour ce faire, il suffit de spécifier la variable tableau (pas besoin de chacune des positions individuelles, ni des parenthèses <span class="inline">[]</span> ) et le tableau entier sera <b>passé par référence</b> dans la fonction :</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>Cependant, lorsque la fonction de <strong>copie en écriture</strong> est activée, le fait de modifier l'une des valeurs du tableau à l'intérieur de la fonction crée une copie temporaire avec vos modifications. Le tableau d'origine n'est pas modifié. Ce comportement est appelé Copy on Write.</p>
  <p>Pour modifier réellement le tableau original qui a été transmis à la fonction, vous devez soit le renvoyer, soit utiliser l'accesseur <span class="inline">@</span>.</p>
  <p>Par exemple, la fonction appelée ci-dessus, <span class="inline2">do_something()</span>, peut faire quelque chose de simple comme ceci :</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>Vous vous attendez à ce que <span class="inline2">mon_tableau</span> contienne les valeurs <span class="inline2">1, 200, 4</span>, etc., ce qui est normalement correct, mais lorsque la fonction de <strong>copie en écriture</strong> est activée, le tableau original n'est pas affecté.</p>
  <p>Pour contourner ce problème, vous pouvez faire en sorte que la fonction <strong>renvoie</strong> la copie modifiée du tableau, puis la réapplique à la variable d'origine :</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>La fonction elle-même renverrait le tableau modifié :</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">NOTE</span><b> </b>Le code ci-dessus n'est pas nécessaire si vous ne modifiez aucune des valeurs du tableau, mais si vous les référencez. Le fait de référencer un tableau ne le copiera pas et sera plus rapide à analyser.</p>
  <p>La deuxième solution consiste à utiliser l'accesseur <span class="inline">@</span> pour modifier directement les valeurs du tableau, ce qui permet d'éviter la surcharge du CPU liée à la réalisation d'une copie temporaire. Cela signifie que vous n'avez pas besoin de retourner le tableau depuis la fonction et que vous pouvez le modifier directement :</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>L'utilisation de cet accesseur contourne le comportement de Copy on Write et modifie directement le tableau référencé. Ceci peut être utilisé pour désactiver sélectivement la copie en écriture pour des instructions spécifiques tout en gardant l'option activée.</p>
  <p>Encore une fois, tout ceci n'est pas nécessaire si la fonction <strong>Copie en écriture</strong> est <strong>désactivée</strong> (ce qui est l'option par défaut et recommandée).</p>
  <p>Vous trouverez de plus amples informations sur les accesseurs et leur fonctionnement, ainsi qu'un exemple pour les tableaux, à la page suivante :</p>
  <ul class="colour">
    <li><a href="Accessors.htm">Accesseurs</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="GML_Overview.htm">Aperçu du GML</a></div>
        <div style="float:right">Suivant : <a data-xref="{title}" href="Structs.htm">Structs &amp; Constructors</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>