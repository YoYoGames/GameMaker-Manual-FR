<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Mouvement et contrôles</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Mouvement et contrôles</h1>
  <p>La <a href="Drawing.htm">section précédente</a> de ce Guide de démarrage rapide a donné quelques exemples pour dessiner des objets à l'écran, mais dessiner des objets ne sert pas à grand chose si vous ne pouvez pas les déplacer... donc dans cette section nous vous donnerons quelques exemples de mouvement pour vos objets, ainsi que quelques schémas de contrôle de base pour différents types de jeux. Tous les exemples sont donnés en utilisant <span class="notranslate">GML</span> Visual ainsi que le code <span class="notranslate">GML</span>, vous pouvez donc utiliser celui avec lequel vous vous sentez le plus à l'aise. Nous vous encourageons donc à explorer tous les liens au fur et à mesure et à utiliser la fonction &quot;recherche&quot; du manuel pour trouver des informations supplémentaires sur tout ce dont vous n'êtes pas sûr.</p>
  <p>Avant d'aller plus loin, vous pouvez créer un nouveau projet ( <span class="notranslate">GML</span> ou <span class="notranslate">GML</span> Visual) à partir de la <a href="../Introduction/The_Start_Page.htm">page de démarrage</a>, et ajouter (ou créer) quelques <span class="notranslate">sprites</span> ainsi qu'un ou deux objets - car nous vous donnerons du code que vous pourrez tester en les utilisant - et vous assurer que le projet dispose d'une pièce dans laquelle placer des instances. Ne vous préoccupez pas trop de l'apparence des <span class="notranslate">sprites</span> que vous créez, car même un simple carré blanc fera l'affaire. Une fois que tout est prêt, vous pouvez commencer à travailler sur les exemples énumérés ci-dessous.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Se déplacer vers la souris</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">L'une des façons les plus simples de faire bouger un objet et d'interagir avec le joueur est d'utiliser la souris. Dans cet exemple, nous allons vous montrer comment utiliser un code de base pour qu'un objet se déplace vers l'endroit où l'utilisateur a cliqué sur le bouton gauche de la souris <img>.</p>
    <p class="dropspot">Pour commencer, ouvrez un objet, attribuez-lui une adresse <span class="notranslate">sprite</span>, puis donnez-lui un <strong>événement global de type "souris gauche vers le bas"</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Nous utilisons les événements de souris <strong>globaux </strong>parce qu'ils détectent un clic n'importe où dans la pièce, alors que les événements de souris ordinaires ne détectent un clic que si la souris clique effectivement dans la <a class="glossterm" data-glossterm="boîte de délimitation" href="#">boîte de délimitation de</a> l'instance. Dans cet événement, nous voulons ajouter ces actions ou ce code :</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Ici, nous demandons à l'instance de se déplacer vers une position sur l'écran, dans ce cas la position &quot;<span class="inline">mouse_x</span>&quot; et &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; et &quot;<span class="inline">mouse_y</span>&quot; sont des<span class="glossextra">variables</span> <strong>intégrées </strong> qui contiennent toujours la position actuelle du curseur de la souris). Le visuel <span class="notranslate">GML</span> le fait en fixant les variables &quot;<span class="inline">direction</span>&quot; et &quot; <span class="inline">speed</span>&quot;. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Variables de l'instance</strong></a>tandis que <span class="notranslate">GML</span> le fait à l'aide de la fonction <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (qui définit également les variables <span class="inline">speed </span>et <span class="inline">direction </span>, en une seule fonction facile à utiliser).</p>
    <p class="dropspot">Placez une instance de cet objet dans une pièce et appuyez sur le bouton Play <img>, puis cliquez sur <img> dans la pièce pour que l'instance se déplace vers la souris :</p>
    <p class="dropspot"><img>Génial ! L'instance de l'objet se déplace maintenant vers l'endroit où vous avez cliqué, et si vous maintenez le bouton enfoncé, l'instance continuera à suivre le curseur de la souris. Cependant, il y a un problème... Après avoir cliqué une fois et relâché, l'instance continuera à se déplacer et finira par quitter la pièce ! Il y a plusieurs façons de résoudre ce problème, et celle que vous choisirez dépendra de ce que vous voulez faire, mais la solution la plus simple pour l'instant est d'ajouter simplement un événement <strong>Global Mouse Button Released</strong>, donc ajoutez-le maintenant à l'objet et donnez-lui ce code :</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">Avec ceci, l'instance ne suivra le curseur de la souris que tant que le bouton de la souris sera maintenu enfoncé, et lorsque vous relâcherez le bouton, elle cessera de se déplacer. Appuyez sur Play <img> et testez-le maintenant.</p>
    <p class="dropspot">Avant de quitter cet exemple, il y a un dernier problème que nous devons résoudre... Si vous cliquez et <em>maintenez le </em>bouton de la souris, mais ne déplacez pas le curseur, alors l'instance se déplacera vers le curseur puis &quot;vibrera&quot; autour de lui. Ceci est dû au fait que l'instance se déplace plus vite qu'un pixel à la fois et &quot;dépasse&quot; la position, puis essaie de revenir en arrière, puis dépasse à nouveau, etc... (augmentez la vitesse de mouvement à 5 ou quelque chose comme ça pour voir le problème si ce n'est pas immédiatement évident).</p>
    <p class="dropspot"><img>Pour résoudre ce problème, nous devons ajouter un <strong>Step Event</strong> à l'objet avec ce code :</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if (_dist &lt;= speed) <br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Ici, nous vérifions simplement la distance entre l'instance et la position de la souris, et si elle est égale ou inférieure à la vitesse actuelle, nous fixons la vitesse à 0. Cela permet à l'instance de s'arrêter lorsqu'elle est suffisamment proche de la position de la souris, et nous n'avons pas le désagréable problème de &quot;vibration&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Mouvement à 4 et 8 voies avec le clavier</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Au début de ce guide</a>, nous vous avons montré l'action et le code suivants pour déplacer une instance vers la droite de deux pixels à chaque étape du jeu :</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Ce type de mouvement est appelé mouvement <strong>positionnel </strong>, car nous prenons essentiellement l'instance et la replaçons à une nouvelle position à chaque fois que le code est exécuté. Dans cet exemple, nous allons vous montrer comment utiliser ce type de mouvement pour déplacer une instance dans 4 directions : haut, bas, gauche et droite.</p>
    <p class="dropspot">Pour commencer, ouvrez un objet et attribuez-lui un <span class="notranslate">sprite</span>. Nous pourrions ajouter divers <strong>événements clavier</strong> à ce stade, et pour chacun d'entre eux, faire en sorte que l'instance se déplace dans la direction souhaitée, cependant, nous voulons que le joueur puisse se déplacer dans une seule direction à la fois et faire cela avec les seuls événements clavier est un peu plus compliqué que de le faire en utilisant du code. A la place, nous utiliserons le <strong>Step Event</strong> - que vous devez ajouter maintenant à l'objet - avec les actions ou le code suivants pour utiliser les touches fléchées pour se déplacer :</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Nous utilisons une structure &quot; <span class="inline">if... else if... else if...</span>&quot; pour nous assurer que l'instance ne se déplacera que dans une seule direction à la fois. Ainsi, l'instance ne devrait pouvoir se déplacer que vers le haut, le bas, la gauche ou la droite, mais pas en diagonale. Placez une instance de l'objet dans une pièce et appuyez sur le bouton <strong>Play </strong> <img> pour le tester maintenant ! Si tout s'est déroulé correctement, vous devriez obtenir quelque chose comme ceci :</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Nous pouvons aussi modifier ce code pour convertir le mouvement à 4 en mouvement à 8 facilement... il suffit de retirer les commandes &quot; <span class="inline">else</span>&quot; des blocs de code pour que tout ressemble à ceci :</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(vk_right)) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(vk_up)) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Maintenant, lorsque vous appuyez sur le bouton <strong>Play </strong> <img>, cela ressemblera à quelque chose comme ça :</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Une dernière chose à noter pour les utilisateurs qui codent avec <span class="notranslate">GML</span>... Lorsque vous utilisez le visuel <span class="notranslate">GML</span>, vous pouvez sélectionner la touche du clavier que vous souhaitez utiliser dans une liste déroulante, mais avec <span class="notranslate">GML</span>, ce n'est pas aussi simple. Il y a un certain nombre de <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">constantes de clavier</a> que vous pouvez utiliser - comme les constantes des touches fléchées montrées dans le code ci-dessus - mais il <em>n'y a pas de </em>constantes pour les touches alpha-numériques. Celles-ci sont gérées de manière légèrement différente et nécessitent l'utilisation de la fonction <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. Le code ci-dessous vous montre comment cela fonctionnerait en utilisant WASD au lieu des touches fléchées :</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;D&quot;))) <br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;W&quot;))) <br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;S&quot;))) <br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Mouvement de la manette de jeu</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Nous avons abordé les mouvements de la souris et du clavier, il est donc temps d'aborder les mouvements du <strong>gamepad </strong>. Nous n'aborderons pas le d-pad, car il fonctionne exactement comme le clavier (il suffit de remplacer les fonctions du clavier dans l'exemple ci-dessus par <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> ou <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">If Gamepad button Down</a>). Dans cet exemple, nous allons donc étudier l'utilisation du stick analogique pour les mouvements.</p>
    <p class="dropspot">Pour commencer, nous devons détecter le gamepad utilisé. Les gamepads ont une valeur d'ID de 0 à 11, nous allons donc utiliser une boucle &quot; <span class="inline">for</span>&quot; pour détecter l'ID de tous les gamepads connectés et stocker cette valeur d'ID dans une variable pour une utilisation future. Puisque nous ne voulons détecter que le premier gamepad connecté et non tous les autres, nous utiliserons la commande &quot; <span class="inline">break</span>&quot; après avoir détecté un gamepad afin qu'il &quot; casse &quot; la boucle (par exemple, si le premier gamepad connecté a l'ID 4, alors la boucle ne s'exécutera que 5 fois, vérifiant les valeurs d'ID 0 - 4 puis cassant la boucle lorsque le gamepad est rencontré). Donc, créez (ou ouvrez) un objet, attribuez-lui un <span class="notranslate">sprite</span>, puis ajoutez un <strong>Create Event</strong> avec ce qui suit :</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if gamepad_is_connected(i)<br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Remarquez que dans le code ci-dessus, nous avons défini le paramètre <strong> <a class="glossterm" data-glossterm="zone morte" href="#">zone morte</a> </strong>pour le gamepad. Cela est dû au fait que les sticks analogiques des différentes marques de gamepads ont une sensibilité différente, et parfois ils peuvent être si sensibles que si vous ne définissez pas de zone morte, ils peuvent provoquer des mouvements indésirables dans vos jeux. Nous définissons donc la zone morte à une valeur telle que 0,2 pour indiquer à <span data-keyref="GameMaker Name">GameMaker</span> d'ignorer toute valeur de stick de gamepad inférieure à cette valeur <a class="glossterm" data-glossterm="absolu" href="#">absolue</a>.</p>
    <p class="dropspot">Pour ajouter le mouvement réel, nous aurons besoin d'un <strong>événement Step</strong>, que nous allons donc ajouter maintenant et lui donner le nom suivant : <span class="notranslate">GML</span> Visual ou GML :</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepads[0], gp_axislh);<br />
          var _v = gamepad_axis_value(gamepads[0], gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Ici, nous vérifions le mouvement horizontal ou vertical du stick <em>gauche </em>. Les fonctions d'axe renvoient une valeur comprise entre -1 et 1, donc pour l'axe horizontal, -1 correspond à la gauche, 0 à l'immobilité et 1 à la droite, et pour l'axe vertical, c'est -1 pour le haut, 0 pour l'immobilité et 1 pour le bas. Notez également que les valeurs sont <em>comprises entre </em>-1 et 1. Ainsi, par exemple, l'axe horizontal pourrait renvoyer une valeur de 0,5, ce qui signifie que le manche est à mi-chemin entre la position &quot;repos&quot; et la position complètement poussée vers la droite. Pour cette raison, nous multiplions ensuite la valeur par 4 (vous pouvez multiplier par n'importe quelle valeur, en fonction de la vitesse à laquelle vous souhaitez que l'instance se déplace) - cela signifie que la vitesse de l'instance variera en fonction de l'ampleur du mouvement effectué sur l'axe du stick.</p>
    <p class="dropspot">Placez une instance de cet objet dans une pièce et appuyez sur le bouton <strong>Play </strong>. <strong> <img></strong>puis déplacez-vous en utilisant le stick gauche de votre gamepad connecté. Vous devriez voir quelque chose comme ceci :</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Mouvement avancé à 8 voies</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">Dans ce dernier exemple, nous allons revoir notre code de mouvement à 8 voies et résoudre un problème qu'il présente, à savoir que le mouvement diagonal est en fait plus rapide que le mouvement vers le haut/bas/gauche/droite. C'est simplement parce que lorsque vous vous déplacez en diagonale, vous vous déplacez le long de l'hypoténuse d'un triangle rectangle créé par les valeurs de mouvement x/y :</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Pour mieux comprendre ce qui se passe, supprimons tout le texte et <span class="notranslate">sprites</span> et montrons simplement la même ligne de mouvement tournée de 45° pour qu'elle soit horizontale :</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Comme vous pouvez le voir, la différence est assez évidente, et si l'instance se déplace de plus de 1 ou 2 pixels par pas, alors il devient très perceptible que le mouvement diagonal est <em>beaucoup </em>plus rapide ! Alors comment limiter cela ? Il y a plusieurs façons de procéder, mais nous allons nous concentrer sur l'une d'entre elles, car elle introduit quelques fonctions et concepts qui vous seront utiles plus tard dans vos jeux.</p>
    <p class="dropspot">Pour gérer cela, nous allons devoir stocker les valeurs d'entrée des touches pressées indépendamment dans des<span class="glossextra">variables</span>, puis les vérifier et nous déplacer en fonction de la combinaison de touches qui ont été pressées. Pour cela, vous aurez besoin d'un objet auquel sera attribué un <span class="notranslate">sprite</span>, et vous devrez lui donner un <strong>Step Event</strong> avec les actions ou le code suivants :</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">NOTE</span> Nous avons réparti les actions visuelles ci-dessus sur deux colonnes pour faciliter la visualisation, mais dans l'éditeur visuel, elles seront placées consécutivement.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Nous devrons ajouter un peu plus de code pour bouger réellement, mais avant cela, expliquons un peu tout cela. Nous voulons convertir les mouvements gauche/droite/haut/bas en valeurs de vitesse horizontale et verticale équivalentes. Pour ce faire, nous obtenons la valeur de chaque touche, puis nous effectuons quelques calculs de base pour obtenir les valeurs de vitesse. Cela fonctionne parce que si une touche est enfoncée, l'action ou la fonction de contrôle renvoie &quot;1&quot;, et si elle <em>ne l'est pas </em>, la fonction renvoie 0. Donc, si - par exemple - la touche droite est pressée, vous avez &quot;1 - 0 = 1&quot; pour le &quot; <span class="inline">_hspd</span>&quot;, et si la touche gauche est pressée, vous avez &quot;0 - 1 = -1&quot; pour le &quot; <span class="inline">_hspd</span>&quot; (et si les deux sont pressées, alors c'est &quot;1 - 1 = 0&quot;, donc l'instance ne bougera pas). Rappelez-vous, dans une room <span data-keyref="GameMaker Name">GameMaker</span>, pour se déplacer vers la droite, on ajoute à la position <span class="inline">x </span>et pour se déplacer vers la gauche, on soustrait. Ce code nous donnera donc une valeur positive ou négative que nous pourrons ajouter ou soustraire pour nous déplacer horizontalement ou verticalement en fonction de l'entrée clavier.</p>
    <p class="dropspot">Maintenant nous pouvons ajouter le code qui déplace réellement l'instance, donc - toujours dans l'<strong>événement Step</strong>, et après le code ci-dessus - ajoutez ceci :</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">Le code ci-dessus vérifie d'abord si l'une des deux<span class="glossextra">expressions</span> est vraie, c'est-à-dire si les variables de vitesse horizontale ou verticale sont différentes de 0. Notez comment la vérification &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> utilise le symbole &quot; <span class="inline">||</span>&quot;. Cela signifie &quot; <span class="inline">or</span>&quot; en programmation, donc - en langage simple - vous vérifiez que</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">Vous pouvez enchaîner plusieurs expressions dans des contrôles &quot; <span class="inline">if</span>&quot; de cette manière, et il existe plusieurs façons différentes d'évaluer ces expressions (pour plus d'informations, veuillez consulter la section sur les <strong>expressions</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">ici</a>).</p>
    <p class="dropspot">La section suivante du code stocke une valeur pour la vitesse de mouvement réelle dans une variable et obtient ensuite une direction en utilisant les valeurs <span class="inline">_hspd </span>et <span class="inline">_vspd </span>, qui peuvent être -1, 0 ou 1. La fonction de direction est vérifiée à partir de (0, 0) car nous n'utilisons pas les coordonnées de la pièce, et nous voulons plutôt qu'elle soit évaluée comme une direction de 0° à 360° basée sur les valeurs de la variable. Le diagramme suivant illustre ce qui se passe mieux que d'essayer de l'expliquer avec des mots :</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">NOTE</span> La direction dans <span data-keyref="GameMaker Name">GameMaker</span> est calculée dans <strong>le sens inverse des aiguilles d'une montre</strong>, donc 0° et 360° sont à droite, 90° est en haut, 180° est à droite et 270° est en bas.</p>
    <p class="dropspot">Enfin, nous utilisons les <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> et <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> pour déplacer réellement la variable. Il s'agit de fonctions <strong> <a class="glossterm" data-glossterm="vecteur" href="#">vecteur</a>  </strong>qui prennent une longueur (distance) et une direction, puis calculent la nouvelle position sur l'axe donné en fonction de ces valeurs (voir les descriptions des fonctions pour une explication plus approfondie).</p>
    <p class="dropspot">Cela fait beaucoup de choses à assimiler d'un coup, et ne vous inquiétez pas si vous ne comprenez pas tout ! Cela viendra avec le temps ! Il ne vous reste plus qu'à ajouter une instance de cet objet dans une pièce, puis à appuyer sur le bouton <strong>"Play" </strong>. <strong> <img></strong>Vous obtiendrez alors un mouvement à 8 voies très fluide, sans aucun des problèmes liés aux déplacements en diagonale :</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Avec ces exemples - et les précédents pour le dessin - nous espérons que vous avez acquis suffisamment de connaissances pour commencer à réaliser vos propres projets ! La dernière page de ce guide de démarrage rapide contient un résumé de certaines des choses que vous avez apprises, ainsi que des liens vers du matériel pédagogique supplémentaire.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Retour : <a href="../Content.htm">Index</a></div>
        <div style="float:right">Suivant : <a href="Summary.htm">Résumé</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tous droits réservés</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>